/**
 * SquirrelDB C Client SDK - Cache Implementation
 * Generated by sdk-generator v0.1.0
 * DO NOT EDIT MANUALLY
 */

#include "squirreldb/cache.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netdb.h>

#define BUFFER_SIZE 4096

struct sqrl_cache {
  int fd;
  char *buffer;
  size_t buffer_size;
  size_t buffer_pos;
  size_t buffer_len;
};

/* RESP protocol helpers */

static ssize_t send_all(int fd, const void *buf, size_t len) {
  const uint8_t *p = buf;
  size_t remaining = len;

  while (remaining > 0) {
    ssize_t n = send(fd, p, remaining, 0);
    if (n < 0) {
      if (errno == EINTR) continue;
      return -1;
    }
    p += n;
    remaining -= n;
  }
  return len;
}

static char *read_line(sqrl_cache_t *cache) {
  char *line = malloc(1024);
  if (!line) return NULL;

  size_t pos = 0;
  while (1) {
    if (cache->buffer_pos >= cache->buffer_len) {
      ssize_t n = recv(cache->fd, cache->buffer, cache->buffer_size, 0);
      if (n <= 0) {
        free(line);
        return NULL;
      }
      cache->buffer_pos = 0;
      cache->buffer_len = n;
    }

    char c = cache->buffer[cache->buffer_pos++];
    if (c == '\n') {
      if (pos > 0 && line[pos - 1] == '\r') pos--;
      line[pos] = '\0';
      return line;
    }
    line[pos++] = c;
  }
}

static char *read_bulk_string(sqrl_cache_t *cache, int len) {
  if (len < 0) return NULL;

  char *str = malloc(len + 1);
  if (!str) return NULL;

  size_t read_pos = 0;
  while (read_pos < (size_t)len) {
    if (cache->buffer_pos >= cache->buffer_len) {
      ssize_t n = recv(cache->fd, cache->buffer, cache->buffer_size, 0);
      if (n <= 0) {
        free(str);
        return NULL;
      }
      cache->buffer_pos = 0;
      cache->buffer_len = n;
    }

    size_t avail = cache->buffer_len - cache->buffer_pos;
    size_t need = len - read_pos;
    size_t copy = avail < need ? avail : need;

    memcpy(str + read_pos, cache->buffer + cache->buffer_pos, copy);
    cache->buffer_pos += copy;
    read_pos += copy;
  }

  str[len] = '\0';

  /* Read trailing \r\n */
  char crlf[2];
  size_t crlf_pos = 0;
  while (crlf_pos < 2) {
    if (cache->buffer_pos >= cache->buffer_len) {
      ssize_t n = recv(cache->fd, cache->buffer, cache->buffer_size, 0);
      if (n <= 0) break;
      cache->buffer_pos = 0;
      cache->buffer_len = n;
    }
    crlf[crlf_pos++] = cache->buffer[cache->buffer_pos++];
  }

  return str;
}

typedef struct resp_value {
  enum { RESP_STRING, RESP_ERROR, RESP_INTEGER, RESP_BULK, RESP_ARRAY, RESP_NIL } type;
  union {
    char *str;
    int64_t integer;
    struct {
      struct resp_value *items;
      size_t count;
    } array;
  } value;
} resp_value_t;

static void free_resp_value(resp_value_t *v) {
  if (!v) return;
  switch (v->type) {
    case RESP_STRING:
    case RESP_ERROR:
    case RESP_BULK:
      free(v->value.str);
      break;
    case RESP_ARRAY:
      for (size_t i = 0; i < v->value.array.count; i++) {
        free_resp_value((resp_value_t*)&v->value.array.items[i]);
      }
      free(v->value.array.items);
      break;
    default:
      break;
  }
}

static sqrl_cache_error_t parse_response(sqrl_cache_t *cache, resp_value_t *out);

static sqrl_cache_error_t parse_response(sqrl_cache_t *cache, resp_value_t *out) {
  char *line = read_line(cache);
  if (!line) return SQRL_CACHE_ERR_RECV;

  char prefix = line[0];
  char *content = line + 1;

  switch (prefix) {
    case '+':
      out->type = RESP_STRING;
      out->value.str = strdup(content);
      break;

    case '-':
      out->type = RESP_ERROR;
      out->value.str = strdup(content);
      break;

    case ':':
      out->type = RESP_INTEGER;
      out->value.integer = strtoll(content, NULL, 10);
      break;

    case '$': {
      int len = atoi(content);
      free(line);
      if (len < 0) {
        out->type = RESP_NIL;
        out->value.str = NULL;
      } else {
        out->type = RESP_BULK;
        out->value.str = read_bulk_string(cache, len);
        if (!out->value.str) return SQRL_CACHE_ERR_RECV;
      }
      return SQRL_CACHE_OK;
    }

    case '*': {
      int count = atoi(content);
      free(line);
      if (count < 0) {
        out->type = RESP_NIL;
        out->value.str = NULL;
      } else {
        out->type = RESP_ARRAY;
        out->value.array.count = count;
        out->value.array.items = calloc(count, sizeof(resp_value_t));
        for (int i = 0; i < count; i++) {
          sqrl_cache_error_t err = parse_response(cache, (resp_value_t*)&out->value.array.items[i]);
          if (err != SQRL_CACHE_OK) return err;
        }
      }
      return SQRL_CACHE_OK;
    }

    default:
      free(line);
      return SQRL_CACHE_ERR_PROTOCOL;
  }

  free(line);
  return SQRL_CACHE_OK;
}

static sqrl_cache_error_t send_command(sqrl_cache_t *cache, const char **args, size_t argc, resp_value_t *response) {
  /* Build RESP array */
  char cmd[8192];
  int pos = snprintf(cmd, sizeof(cmd), "*%zu\r\n", argc);

  for (size_t i = 0; i < argc; i++) {
    size_t len = strlen(args[i]);
    pos += snprintf(cmd + pos, sizeof(cmd) - pos, "$%zu\r\n%s\r\n", len, args[i]);
  }

  if (send_all(cache->fd, cmd, pos) < 0) {
    return SQRL_CACHE_ERR_SEND;
  }

  sqrl_cache_error_t err = parse_response(cache, response);
  if (err != SQRL_CACHE_OK) return err;

  if (response->type == RESP_ERROR) {
    return SQRL_CACHE_ERR_SERVER;
  }

  return SQRL_CACHE_OK;
}

/* Public API */

sqrl_cache_options_t sqrl_cache_options_default(void) {
  sqrl_cache_options_t opts = {
    .host = "localhost",
    .port = 6379,
    .timeout_ms = 5000
  };
  return opts;
}

const char *sqrl_cache_error_string(sqrl_cache_error_t err) {
  switch (err) {
    case SQRL_CACHE_OK: return "Success";
    case SQRL_CACHE_ERR_CONNECT: return "Connection failed";
    case SQRL_CACHE_ERR_SEND: return "Send failed";
    case SQRL_CACHE_ERR_RECV: return "Receive failed";
    case SQRL_CACHE_ERR_PROTOCOL: return "Protocol error";
    case SQRL_CACHE_ERR_SERVER: return "Server error";
    case SQRL_CACHE_ERR_MEMORY: return "Memory allocation failed";
    case SQRL_CACHE_ERR_CLOSED: return "Connection closed";
    default: return "Unknown error";
  }
}

sqrl_cache_error_t sqrl_cache_connect(sqrl_cache_t **cache_out, const sqrl_cache_options_t *options) {
  if (!cache_out) return SQRL_CACHE_ERR_MEMORY;

  sqrl_cache_options_t opts = options ? *options : sqrl_cache_options_default();

  sqrl_cache_t *cache = calloc(1, sizeof(sqrl_cache_t));
  if (!cache) return SQRL_CACHE_ERR_MEMORY;

  cache->buffer = malloc(BUFFER_SIZE);
  if (!cache->buffer) {
    free(cache);
    return SQRL_CACHE_ERR_MEMORY;
  }
  cache->buffer_size = BUFFER_SIZE;

  struct addrinfo hints = {0}, *res = NULL;
  hints.ai_family = AF_UNSPEC;
  hints.ai_socktype = SOCK_STREAM;

  char port_str[16];
  snprintf(port_str, sizeof(port_str), "%u", opts.port);

  if (getaddrinfo(opts.host, port_str, &hints, &res) != 0) {
    free(cache->buffer);
    free(cache);
    return SQRL_CACHE_ERR_CONNECT;
  }

  cache->fd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
  if (cache->fd < 0) {
    freeaddrinfo(res);
    free(cache->buffer);
    free(cache);
    return SQRL_CACHE_ERR_CONNECT;
  }

  int flag = 1;
  setsockopt(cache->fd, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag));

  if (connect(cache->fd, res->ai_addr, res->ai_addrlen) < 0) {
    freeaddrinfo(res);
    close(cache->fd);
    free(cache->buffer);
    free(cache);
    return SQRL_CACHE_ERR_CONNECT;
  }

  freeaddrinfo(res);
  *cache_out = cache;
  return SQRL_CACHE_OK;
}

void sqrl_cache_disconnect(sqrl_cache_t *cache) {
  if (!cache) return;
  if (cache->fd >= 0) close(cache->fd);
  free(cache->buffer);
  free(cache);
}

sqrl_cache_error_t sqrl_cache_get(sqrl_cache_t *cache, const char *key, char **value_out) {
  if (!cache || !key || !value_out) return SQRL_CACHE_ERR_MEMORY;

  const char *args[] = {"GET", key};
  resp_value_t resp = {0};

  sqrl_cache_error_t err = send_command(cache, args, 2, &resp);
  if (err != SQRL_CACHE_OK) return err;

  if (resp.type == RESP_BULK || resp.type == RESP_STRING) {
    *value_out = resp.value.str;
    return SQRL_CACHE_OK;
  }

  *value_out = NULL;
  return SQRL_CACHE_OK;
}

sqrl_cache_error_t sqrl_cache_set(sqrl_cache_t *cache, const char *key, const char *value, int64_t ttl_seconds) {
  if (!cache || !key || !value) return SQRL_CACHE_ERR_MEMORY;

  resp_value_t resp = {0};
  sqrl_cache_error_t err;

  if (ttl_seconds > 0) {
    char ttl_str[32];
    snprintf(ttl_str, sizeof(ttl_str), "%lld", (long long)ttl_seconds);
    const char *args[] = {"SET", key, value, "EX", ttl_str};
    err = send_command(cache, args, 5, &resp);
  } else {
    const char *args[] = {"SET", key, value};
    err = send_command(cache, args, 3, &resp);
  }

  free_resp_value(&resp);
  return err;
}

sqrl_cache_error_t sqrl_cache_del(sqrl_cache_t *cache, const char *key, bool *deleted) {
  if (!cache || !key) return SQRL_CACHE_ERR_MEMORY;

  const char *args[] = {"DEL", key};
  resp_value_t resp = {0};

  sqrl_cache_error_t err = send_command(cache, args, 2, &resp);
  if (err != SQRL_CACHE_OK) return err;

  if (deleted && resp.type == RESP_INTEGER) {
    *deleted = resp.value.integer > 0;
  }

  return SQRL_CACHE_OK;
}

sqrl_cache_error_t sqrl_cache_exists(sqrl_cache_t *cache, const char *key, bool *exists) {
  if (!cache || !key) return SQRL_CACHE_ERR_MEMORY;

  const char *args[] = {"EXISTS", key};
  resp_value_t resp = {0};

  sqrl_cache_error_t err = send_command(cache, args, 2, &resp);
  if (err != SQRL_CACHE_OK) return err;

  if (exists && resp.type == RESP_INTEGER) {
    *exists = resp.value.integer > 0;
  }

  return SQRL_CACHE_OK;
}

sqrl_cache_error_t sqrl_cache_incr(sqrl_cache_t *cache, const char *key, int64_t *result) {
  if (!cache || !key) return SQRL_CACHE_ERR_MEMORY;

  const char *args[] = {"INCR", key};
  resp_value_t resp = {0};

  sqrl_cache_error_t err = send_command(cache, args, 2, &resp);
  if (err != SQRL_CACHE_OK) return err;

  if (result && resp.type == RESP_INTEGER) {
    *result = resp.value.integer;
  }

  return SQRL_CACHE_OK;
}

sqrl_cache_error_t sqrl_cache_decr(sqrl_cache_t *cache, const char *key, int64_t *result) {
  if (!cache || !key) return SQRL_CACHE_ERR_MEMORY;

  const char *args[] = {"DECR", key};
  resp_value_t resp = {0};

  sqrl_cache_error_t err = send_command(cache, args, 2, &resp);
  if (err != SQRL_CACHE_OK) return err;

  if (result && resp.type == RESP_INTEGER) {
    *result = resp.value.integer;
  }

  return SQRL_CACHE_OK;
}

sqrl_cache_error_t sqrl_cache_ping(sqrl_cache_t *cache) {
  if (!cache) return SQRL_CACHE_ERR_MEMORY;

  const char *args[] = {"PING"};
  resp_value_t resp = {0};

  sqrl_cache_error_t err = send_command(cache, args, 1, &resp);
  if (err != SQRL_CACHE_OK) return err;

  if (resp.type == RESP_STRING && strcmp(resp.value.str, "PONG") == 0) {
    free(resp.value.str);
    return SQRL_CACHE_OK;
  }

  free_resp_value(&resp);
  return SQRL_CACHE_ERR_PROTOCOL;
}

sqrl_cache_error_t sqrl_cache_dbsize(sqrl_cache_t *cache, int64_t *size_out) {
  if (!cache || !size_out) return SQRL_CACHE_ERR_MEMORY;

  const char *args[] = {"DBSIZE"};
  resp_value_t resp = {0};

  sqrl_cache_error_t err = send_command(cache, args, 1, &resp);
  if (err != SQRL_CACHE_OK) return err;

  if (resp.type == RESP_INTEGER) {
    *size_out = resp.value.integer;
  }

  return SQRL_CACHE_OK;
}

sqrl_cache_error_t sqrl_cache_flushdb(sqrl_cache_t *cache) {
  if (!cache) return SQRL_CACHE_ERR_MEMORY;

  const char *args[] = {"FLUSHDB"};
  resp_value_t resp = {0};

  sqrl_cache_error_t err = send_command(cache, args, 1, &resp);
  free_resp_value(&resp);
  return err;
}
